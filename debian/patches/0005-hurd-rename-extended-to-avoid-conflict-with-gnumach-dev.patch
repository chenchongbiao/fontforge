Description: Rename extended to extendeddbl to avoid FTBFS on Hurd
 gnumach-dev 1.8+git20201129 added to i386/include/mach/i386/fp_reg.h
 (struct i386_xfp_save) a new "extended" field which happens to collide
 with "extended" type in FontForge, leading to FTBFS on Hurd:
 .
     FAILED: fontforge/CMakeFiles/fontforge.dir/asmfpst.c.o 
     /usr/bin/cc -Dfontforge_EXPORTS -I../../fontforge -I../../inc -Iinc -isystem /usr/include/glib-2.0 -isystem /usr/lib/i386-gnu/glib-2.0/include -isystem /usr/include/freetype2 -isystem /usr/include/libxml2 -isystem /usr/include/readline -isystem /usr/include/python3.9 -g -O2 -ffile-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -Werror=implicit-function-declaration -Werror=int-conversion -fdiagnostics-color=always -std=gnu99 -MD -MT fontforge/CMakeFiles/fontforge.dir/asmfpst.c.o -MF fontforge/CMakeFiles/fontforge.dir/asmfpst.c.o.d -o fontforge/CMakeFiles/fontforge.dir/asmfpst.c.o -c ../../fontforge/asmfpst.c
     In file included from ../../fontforge/asmfpst.h:4,
                      from ../../fontforge/asmfpst.c:30:
     ../../fontforge/splinefont.h:63:18: error: two or more data types in declaration specifiers
        63 | #define extended double
           |                  ^~~~~~
     In file included from /usr/include/i386-gnu/bits/sigcontext.h:30,
                      from /usr/include/signal.h:291,
                      from /usr/include/glib-2.0/glib/gbacktrace.h:36,
                      from /usr/include/glib-2.0/glib.h:34,
                      from /usr/include/glib-2.0/gobject/gbinding.h:28,
                      from /usr/include/glib-2.0/glib-object.h:22,
                      from /usr/include/glib-2.0/gio/gioenums.h:28,
                      from /usr/include/glib-2.0/gio/giotypes.h:28,
                      from /usr/include/glib-2.0/gio/gio.h:26,
                      from ../../inc/ffglib.h:29,
                      from ../../fontforge/baseviews.h:31,
                      from ../../fontforge/fontforgevw.h:31,
                      from ../../fontforge/asmfpst.c:33:
     /usr/include/i386-gnu/mach/i386/fp_reg.h:80:24: error: expected identifier or ‘(’ before ‘[’ token
        80 |  unsigned char extended[0]; /* Extended region */
           |                        ^
 .
 This patch rename "extended" to "extendeddbl" to avoid the name collision.
Author: Anthony Fok <foka@debian.org>
Origin: vendor
Forwarded: no
Last-Update: 2021-01-15
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/fontforge/autohint.c
+++ b/fontforge/autohint.c
@@ -706,7 +706,7 @@
 }
 
 static void EIAddSpline(Spline *spline, EIList *el) {
-    extended ts[6], temp;
+    extendeddbl ts[6], temp;
     int i, j, base, last;
 
     ts[0] = 0; ts[5] = 1.0;
--- a/fontforge/autowidth.c
+++ b/fontforge/autowidth.c
@@ -260,7 +260,7 @@
 }
 
 static real SplineFindMinXAtY(Spline *spline,real y,real min) {
-    extended t,t1,t2,tbase,val;
+    extendeddbl t,t1,t2,tbase,val;
     Spline1D *xsp;
 
     if ( y>spline->from->me.y && y>spline->from->nextcp.y &&
@@ -321,7 +321,7 @@
 
 static void SplineFindEdges(Spline *spline,struct charone *ch, WidthInfo *wi) {
     Spline1D *xsp, *ysp;
-    extended t1, t2;
+    extendeddbl t1, t2;
     double t, toff, ymin, ymax;
 
     /* first try the end points */
--- a/fontforge/edgelist2.h
+++ b/fontforge/edgelist2.h
@@ -36,7 +36,7 @@
     Spline *s;
     struct monotonic *m;			/* May get slightly munched but will */
 			/* always have right spline. we fix when we need it */
-    extended t;
+    extendeddbl t;
     int isend;
     BasePoint unit;
     struct mlist *next;
@@ -60,9 +60,9 @@
 
 typedef struct monotonic {
     Spline *s;
-    extended tstart, tend;
+    extendeddbl tstart, tend;
 #ifdef FF_RELATIONAL_GEOM
-    extended otstart, otend;
+    extendeddbl otstart, otend;
 #endif
     struct monotonic *next, *prev;	/* along original contour */
     uint8 xup;				/* increasing t => increasing x */
@@ -74,7 +74,7 @@
     struct intersection *start;
     struct intersection *end;
     DBounds b;
-    extended other, t;
+    extendeddbl other, t;
     struct monotonic *linked;		/* singly linked list of all monotonic*/
     					/*  segments, no contour indication */
     double when_set;			/* Debugging */
--- a/fontforge/effects.c
+++ b/fontforge/effects.c
@@ -411,7 +411,7 @@
 }
 
 static bigreal IntersectLine(Spline *spline1,Spline *spline2) {
-    extended t1s[10], t2s[10];
+    extendeddbl t1s[10], t2s[10];
     BasePoint pts[9];
     bigreal mint=1;
     int i;
@@ -458,16 +458,16 @@
 
 /* finds all intersections between this spline and all the other splines in the */
 /*  character */
-static extended *BottomFindIntersections(Spline *bottom,SplineSet *lines,SplineSet *spl) {
-    extended *ts;
+static extendeddbl *BottomFindIntersections(Spline *bottom,SplineSet *lines,SplineSet *spl) {
+    extendeddbl *ts;
     int tcnt, tmax;
-    extended t1s[26], t2s[26];
+    extendeddbl t1s[26], t2s[26];
     BasePoint pts[25];
     Spline *first, *s;
     int i,j;
 
     tmax = 100;
-    ts = malloc(tmax*sizeof(extended));
+    ts = malloc(tmax*sizeof(extendeddbl));
     tcnt = 0;
 
     while ( spl!=NULL ) {
@@ -477,7 +477,7 @@
 		for ( i=0; i<25 && t1s[i]!=-1; ++i ) if ( t2s[i]>.001 && t2s[i]<.999 ) {
 		    if ( tcnt>=tmax ) {
 			tmax += 100;
-			ts = realloc(ts,tmax*sizeof(extended));
+			ts = realloc(ts,tmax*sizeof(extendeddbl));
 		    }
 		    ts[tcnt++] = t1s[i];
 		}
@@ -493,7 +493,7 @@
 		for ( i=0; i<25 && t1s[i]!=-1; ++i ) if ( t2s[i]>.001 && t2s[i]<.999 ) {
 		    if ( tcnt>=tmax ) {
 			tmax += 100;
-			ts = realloc(ts,tmax*sizeof(extended));
+			ts = realloc(ts,tmax*sizeof(extendeddbl));
 		    }
 		    ts[tcnt++] = t1s[i];
 		}
@@ -508,7 +508,7 @@
     }
     for ( i=0; i<tcnt; ++i ) for ( j=i+1; j<tcnt; ++j ) {
 	if ( ts[i]>ts[j] ) {
-	    extended temp = ts[i];
+	    extendeddbl temp = ts[i];
 	    ts[i] = ts[j];
 	    ts[j] = temp;
 	}
@@ -624,7 +624,7 @@
 	bigreal shadow_length) {
     SplineSet *head=NULL, *last=NULL, *cur, *next;
     Spline *s;
-    extended *ts;
+    extendeddbl *ts;
     SplinePoint *sp;
     int i;
 
--- a/fontforge/fvcomposite.c
+++ b/fontforge/fvcomposite.c
@@ -1407,7 +1407,7 @@
 static real _SplineSetFindXRangeAtYExtremum(SplinePointList *spl, DBounds *bounds,
 	int findymax, real yextreme) {
     Spline *spline;
-    extended t0, t1, t2, t3;
+    extendeddbl t0, t1, t2, t3;
     bigreal y0, y1, y2, y3, x;
 
     for ( ; spl!=NULL; spl = spl->next ) {
--- a/fontforge/glyphcomp.c
+++ b/fontforge/glyphcomp.c
@@ -93,7 +93,7 @@
 /* ************************************************************************** */
 
 static double FindNewT(double pos,const Spline1D *s,double old_t) {
-    extended ts[3];
+    extendeddbl ts[3];
     int i;
     double closest;
 
@@ -114,7 +114,7 @@
 static int NearSplineSet(BasePoint *here,const SplineSet *ss,
 	const Spline **last_found,double *last_t,double err) {
     const Spline *first, *s, *best_s;
-    extended ts[3];
+    extendeddbl ts[3];
     double dx, dy, adx, ady, best, best_t, t;
     BasePoint test;
     int i, j;
--- a/fontforge/scripting.c
+++ b/fontforge/scripting.c
@@ -7633,7 +7633,7 @@
 
 static void FigureSplExt(SplineSet *spl,int pos,int xextrema, double minmax[2]) {
     Spline *s, *first;
-    extended ts[3];
+    extendeddbl ts[3];
     int oth = !xextrema, i;
     double val;
 
@@ -7704,7 +7704,7 @@
 #define MAXSECT 100
   SplineSet *spl;
   Spline *s, *first;
-  extended ts[3];
+  extendeddbl ts[3];
   int oth = !xextrema, i, j = 0, l, m;
   double *val = NULL, temp;
   RefChar *r;
--- a/fontforge/scstyles.c
+++ b/fontforge/scstyles.c
@@ -4691,7 +4691,7 @@
     real trans[6];
     int i;
     double spos, epos, dpos;
-    extended t1, t2;
+    extendeddbl t1, t2;
     SplinePoint *sp;
     Spline *s;
     double cur_sw;
@@ -5265,7 +5265,7 @@
 		 (!sp->noprevcp && other->me.y>sp->prevcp.y)) ) {
 	    /* We need to move sp up, but we can't because it turns down */
 	    /*  So instead, move "other" down to sp */
-	    extended ts[3];
+	    extendeddbl ts[3];
 	    /* Well, we might be able to move it up a little... */
 	    if ( sp->prev->from->me.x==sp->me.x ) {
 		SplinePoint *newsp = sp->prev->from;
@@ -5296,7 +5296,7 @@
 	if ( sp->me.y<other->me.y &&
 		(( sp->nonextcp && other->me.y>sp->next->to->me.y) ||
 		 (!sp->nonextcp && other->me.y>sp->nextcp.y)) ) {
-	    extended ts[3];
+	    extendeddbl ts[3];
 	    if ( sp->next->to->me.x==sp->me.x ) {
 		SplinePoint *newsp = sp->next->to;
 		SplineFree(sp->next);
@@ -5568,7 +5568,7 @@
 		 (!sp->noprevcp && other->me.y<sp->prevcp.y)) ) {
 	    /* We need to move sp up, but we can't because it turns down */
 	    /*  So instead, move "other" down to sp */
-	    extended ts[3];
+	    extendeddbl ts[3];
 	    /* Well, we might be able to move it up a little... */
 	    if ( sp->prev->from->me.x==sp->me.x ) {
 		SplinePoint *newsp = sp->prev->from;
@@ -5599,7 +5599,7 @@
 	if ( sp->me.y>other->me.y &&
 		(( sp->nonextcp && other->me.y<sp->next->to->me.y) ||
 		 (!sp->nonextcp && other->me.y<sp->nextcp.y)) ) {
-	    extended ts[3];
+	    extendeddbl ts[3];
 	    if ( sp->next->to->me.x==sp->me.x ) {
 		SplinePoint *newsp = sp->next->to;
 		SplineFree(sp->next);
@@ -6465,7 +6465,7 @@
     SplinePoint *start, *end, *ltemp, *rtemp;
     int scnt, left_is_start;
     double stemwidth, drop, min;
-    extended ts[3];
+    extendeddbl ts[3];
 
     if ( d==NULL )
 return;
--- a/fontforge/splinechar.c
+++ b/fontforge/splinechar.c
@@ -1523,7 +1523,7 @@
     StemInfo *h;
     SplineSet *base;
     bigreal len2, bound2, x, y;
-    extended extrema[4];
+    extendeddbl extrema[4];
     PST *pst;
     struct ttf_table *tab;
     extern int allow_utf8_glyphnames;
@@ -1927,7 +1927,7 @@
 static int CutCircle(SplineSet *spl,BasePoint *me,int first) {
     Spline *s, *firsts;
     SplinePoint *end;
-    extended ts[3];
+    extendeddbl ts[3];
     int i;
     bigreal best_t = -1;
     Spline *best_s = NULL;
--- a/fontforge/splinefill.c
+++ b/fontforge/splinefill.c
@@ -385,7 +385,7 @@
     AddEdge(es,sp,t,1.0);
     if ( es->interesting ) {
 	/* Also store up points of extrema in X as interesting (we got the endpoints, just internals now)*/
-	extended ot1, ot2;
+	extendeddbl ot1, ot2;
 	int mpos;
 	SplineFindExtrema(osp,&ot1,&ot2);
 	if ( ot1>0 && ot1<1 ) {
--- a/fontforge/splinefit.c
+++ b/fontforge/splinefit.c
@@ -408,7 +408,7 @@
     /* We want to find t so that spline(t) = sought */
     /*  find the value which is closest to close_to_t */
     /* on error return closetot */
-    extended ts[3];
+    extendeddbl ts[3];
     int i;
     bigreal t, best, test;
 
@@ -436,7 +436,7 @@
     int i;
     bigreal xdiff, ydiff, sum, temp, t;
     SplinePoint *to = spline->to, *from = spline->from;
-    extended ts[2], x,y;
+    extendeddbl ts[2], x,y;
     struct dotbounds db2;
     bigreal dot;
     int near_vert, near_horiz;
--- a/fontforge/splinefont.c
+++ b/fontforge/splinefont.c
@@ -1546,7 +1546,7 @@
     enum flatness f = mt_unknown;
     bigreal max = -1.0e23;
     Spline *s, *first;
-    extended ts[2];
+    extendeddbl ts[2];
     int i;
 
     for ( ; spl!=NULL; spl=spl->next ) {
@@ -1620,7 +1620,7 @@
     enum flatness f = mt_unknown;
     bigreal min = 1.0e23;
     Spline *s, *first;
-    extended ts[2];
+    extendeddbl ts[2];
     int i;
 
     for ( ; spl!=NULL; spl=spl->next ) {
--- a/fontforge/splinefont.h
+++ b/fontforge/splinefont.h
@@ -60,7 +60,7 @@
 # define bigreal	double
 #endif
 
-#define extended	double
+#define extendeddbl	double
 	/* Solaris wants to define extended to be unsigned [3] unless we do this*/
 #define _EXTENDED
 
@@ -2244,11 +2244,11 @@
 };
 #define STD_BDF_PROPS_EMPTY { NULL, 0, 0 }
 
-extern int CubicSolve(const Spline1D *sp,bigreal sought,extended ts[3]);
+extern int CubicSolve(const Spline1D *sp,bigreal sought,extendeddbl ts[3]);
 /* Uses an algebraic solution */
-extern extended SplineSolve(const Spline1D *sp, real tmin, real tmax, extended sought_y);
+extern extendeddbl SplineSolve(const Spline1D *sp, real tmin, real tmax, extendeddbl sought_y);
 /* Tries to fixup rounding errors that crept in to the solution */
-extern extended SplineSolveFixup(const Spline1D *sp, real tmin, real tmax, extended sought_y);
+extern extendeddbl SplineSolveFixup(const Spline1D *sp, real tmin, real tmax, extendeddbl sought_y);
 /* Uses an iterative approximation */
 /* Uses an iterative approximation and then tries to fix things up */
 
--- a/fontforge/splineorder2.c
+++ b/fontforge/splineorder2.c
@@ -72,7 +72,7 @@
     real d, o;
     real ttf_t, sq, val;
     DBounds bb;
-    extended ts[3];
+    extendeddbl ts[3];
     int i;
 
     /* Are all points on ttf near points on ps? */
@@ -397,7 +397,7 @@
 }
 
 static SplinePoint *__ttfApprox(Spline *ps,real tmin, real tmax, SplinePoint *start) {
-    extended inflect[2];
+    extendeddbl inflect[2];
     int i=0;
     SplinePoint *end;
     Spline *s, *next;
@@ -738,7 +738,7 @@
 
 static SplinePoint *ttfApprox(Spline *ps, SplinePoint *start) {
 #if !defined(FONTFORGE_CONFIG_NON_SYMMETRIC_QUADRATIC_CONVERSION)
-    extended magicpoints[6], last;
+    extendeddbl magicpoints[6], last;
     int cnt, i, j, qcnt, test_level;
     QPoint data[8*10];
     int round_to_int =
--- a/fontforge/splineoverlap.c
+++ b/fontforge/splineoverlap.c
@@ -138,7 +138,7 @@
 #define ValidateMListTs_IF_VERBOSE(input) 
 #endif
 
-static extended evalSpline(Spline *s, extended t, int dim) {
+static extendeddbl evalSpline(Spline *s, extendeddbl t, int dim) {
   return ((s->splines[dim].a*t+s->splines[dim].b)*t+s->splines[dim].c)*t+s->splines[dim].d;
 }
 
@@ -202,7 +202,7 @@
     }
 }
 
-static Monotonic *SplineToMonotonic(Spline *s,extended startt,extended endt,
+static Monotonic *SplineToMonotonic(Spline *s,extendeddbl startt,extendeddbl endt,
 	Monotonic *last,int exclude) {
     Monotonic *m;
     BasePoint start, end;
@@ -335,11 +335,11 @@
 
 static Monotonic *SSToMContour(SplineSet *spl, Monotonic *start,
 	Monotonic **end, enum overlap_type ot) {
-    extended ts[4];
+    extendeddbl ts[4];
     Spline *first, *s;
     Monotonic *head=NULL, *last=NULL;
     int cnt, i, selected = false;
-    extended lastt;
+    extendeddbl lastt;
 
     if ( spl->first->prev==NULL )
 return( start );		/* Open contours have no interior, ignore 'em */
@@ -401,7 +401,7 @@
 return( head );
 }
 
-static void _AddSpline(Intersection *il,Monotonic *m,extended t,int isend) {
+static void _AddSpline(Intersection *il,Monotonic *m,extendeddbl t,int isend) {
     // This adds a monotonic spline to the list of splines attached
     // to a given intersection, with the t-value at which it intersects.
     // It also updates the spline so that it starts or ends at the correct point.
@@ -450,7 +450,7 @@
     if (current->m == findm && current->isend == isend) { current->m = replacem; }
 }
 
-static void MListReplaceMonotonicT(struct mlist * input, struct monotonic * findm, int isend, extended t) {
+static void MListReplaceMonotonicT(struct mlist * input, struct monotonic * findm, int isend, extendeddbl t) {
   // This replaces a reference to one monotonic with a reference to another.
   struct mlist * current;
   for (current = input; current != NULL; current = current->next)
@@ -487,8 +487,8 @@
   return;
 }
 
-static extended FixMonotonicT(struct monotonic * input_mono, extended startt, extended x, extended y) {
-  extended tmpt;
+static extendeddbl FixMonotonicT(struct monotonic * input_mono, extendeddbl startt, extendeddbl x, extendeddbl y) {
+  extendeddbl tmpt;
   if (input_mono->s->from->me.x == x && input_mono->s->from->me.y == y) {
     return 0;
   } else if (input_mono->s->to->me.x == x && input_mono->s->to->me.y == y) {
@@ -549,7 +549,7 @@
 }
 
 static void MoveIntersection(Intersection *input2, real newx, real newy) {
-  extended tmpt;
+  extendeddbl tmpt;
 ValidateMListTs_IF_VERBOSE(input2->monos)
   // For each element in input2->monos, we want to remap intersections from input2 to input1.
   struct mlist * spline_mod;
@@ -623,7 +623,7 @@
 }
 
 static void MergeIntersections(Intersection *input1, Intersection *input2) {
-  extended tmpt;
+  extendeddbl tmpt;
 ValidateMListTs_IF_VERBOSE(input1->monos)
 ValidateMListTs_IF_VERBOSE(input2->monos)
   // For each element in input2->monos, we want to remap intersections from input2 to input1.
@@ -745,7 +745,7 @@
 
 #define evalCubicSpline(spline, t) ((((spline).a * (t) + (spline).b) * (t) + (spline).c) * (t) + (spline).d)
 
-static void AddSpline(Intersection *il,Monotonic *m,extended t) {
+static void AddSpline(Intersection *il,Monotonic *m,extendeddbl t) {
     MList *ml;
 
 ValidateMListTs_IF_VERBOSE(il->monos)
@@ -850,7 +850,7 @@
               oldend.x = 0.0;
               oldend.y = 0.0;
             }
-            extended oldtend = m->tend;
+            extendeddbl oldtend = m->tend;
 	    *m2 = *m;
 	    m2->pending = NULL;
 	    m->next = m2;
@@ -1068,13 +1068,13 @@
 // Validate(m, NULL);
 }
 
-static extended RealDistance(extended v1, extended v2) {
+static extendeddbl RealDistance(extendeddbl v1, extendeddbl v2) {
   if (v2 > v1) return v2 - v1;
   else if (v2 < v1) return v1 - v2;
   return 0.0;
 }
 
-static int RealCloser(extended ref0, extended ref1, extended queryval) {
+static int RealCloser(extendeddbl ref0, extendeddbl ref1, extendeddbl queryval) {
   if (RealDistance(ref1, queryval) < RealDistance(ref0, queryval)) return 1;
   return 0;
 }
@@ -1083,7 +1083,7 @@
 	struct inter_data *id, int doit) {
     bigreal t=0;
     int low=0, high=0;
-    extended startx, starty, endx, endy;
+    extendeddbl startx, starty, endx, endy;
     {
       // We set our fallback values.
       if (m->tstart == 0) {
@@ -1236,15 +1236,15 @@
 /*  are [0,1], let's use 1.0/D_RE_Factor */
 
 static int ImproveInter(Monotonic *m1, Monotonic *m2,
-	extended *_t1,extended *_t2,BasePoint *inter) {
+	extendeddbl *_t1,extendeddbl *_t2,BasePoint *inter) {
     Spline *s1 = m1->s, *s2 = m2->s;
-    extended x1, x2, y1, y2;
-    extended t1p, t1m, t2p, t2m;
-    extended x1p, x1m, x2p, x2m, y1p, y1m, y2p, y2m;
-    extended error, errors[9], beste;
+    extendeddbl x1, x2, y1, y2;
+    extendeddbl t1p, t1m, t2p, t2m;
+    extendeddbl x1p, x1m, x2p, x2m, y1p, y1m, y2p, y2m;
+    extendeddbl error, errors[9], beste;
     int i, besti;
-    extended factor;
-    extended t1,t2;
+    extendeddbl factor;
+    extendeddbl t1,t2;
     int cnt=1, clamp;
     /* We want to find (t1,t2) so that (m1(t1)-m2(t2))^2==0 */
     /* Make slight adjustments to the t?s in all directions and see if that */
@@ -1263,8 +1263,8 @@
     for ( clamp = 1; clamp>=0; --clamp ) {
 	factor = sqrt(error); /* 32*1024.0*1024.0*1024.0/BR_RE_Factor;*/
 	for ( cnt=0; cnt<51; ++cnt ) {
-	    extended off1 = factor*t1;
-	    extended off2 = factor*t2;
+	    extendeddbl off1 = factor*t1;
+	    extendeddbl off2 = factor*t2;
 	    if ( t1<.0001 ) off1 = factor;
 	    if ( t2<.0001 ) off2 = factor;
 	    if ( clamp ) {
@@ -1331,7 +1331,7 @@
 }
 
 static Intersection *_AddIntersection(Intersection *ilist,Monotonic *m1,
-	Monotonic *m2,extended t1,extended t2,BasePoint *inter) {
+	Monotonic *m2,extendeddbl t1,extendeddbl t2,BasePoint *inter) {
     Intersection *il, *closest=NULL;
     bigreal dist, dx, dy, bestd=9e10;
 
@@ -1433,9 +1433,9 @@
 }
 
 static Intersection *AddIntersection(Intersection *ilist,Monotonic *m1,
-	Monotonic *m2,extended t1,extended t2,BasePoint *inter) {
+	Monotonic *m2,extendeddbl t1,extendeddbl t2,BasePoint *inter) {
     Intersection *il;
-    extended ot1 = t1, ot2 = t2;
+    extendeddbl ot1 = t1, ot2 = t2;
 // ValidateMonotonic(m1);
 // ValidateMonotonic(m2);
     for ( il = ilist; il!=NULL; il=il->next ) {
@@ -1590,7 +1590,7 @@
 }
 
 static Intersection *AddCloseIntersection(Intersection *ilist,Monotonic *m1,
-	Monotonic *m2,extended t1,extended t2,BasePoint *inter) {
+	Monotonic *m2,extendeddbl t1,extendeddbl t2,BasePoint *inter) {
 
     if ( t1<m1->tstart+.01 && CloserT(m1->s,m1->tstart,t1,m2->s,t2) ) {
 	if ( m1->start!=NULL )	/* Since we use the m2 inter value, life gets confused if we've already got a different intersection here */
@@ -1624,7 +1624,7 @@
 }
 
 static void AddPreIntersection(Monotonic *m1, Monotonic *m2,
-	extended t1,extended t2,BasePoint *inter, int isclose) {
+	extendeddbl t1,extendeddbl t2,BasePoint *inter, int isclose) {
     PreIntersection *p;
 
     /* This is just a join between two adjacent monotonics. There might already*/
@@ -1658,7 +1658,7 @@
     DBounds b;
     const bigreal error = .00001;
     BasePoint pt;
-    extended t1,t2;
+    extendeddbl t1,t2;
     int pick;
     int oncebefore=false;
 
@@ -1672,7 +1672,7 @@
 
     if ( b.maxy==b.miny && b.minx==b.maxx ) {
         // This essentially means that we know exactly where the intersection is.
-	extended x1,y1, x2,y2, t1,t2;
+	extendeddbl x1,y1, x2,y2, t1,t2;
 	if ( m1->next==m2 || m2->next==m1 )
 return;		/* Not interesting. Only intersection is at a shared endpoint */
 	if ( ((m1->start==m2->start || m1->end==m2->start) && m2->start!=NULL) ||
@@ -1699,7 +1699,7 @@
 	}
     } else if ( b.maxy==b.miny ) {
         // We know the y-dimension of the intersection.
-	extended x1,x2;
+	extendeddbl x1,x2;
 	if ( m1->next==m2 || m2->next==m1 )
 return;		/* Not interesting. Only intersection is at a shared endpoint */
 	if (( b.maxy==m1->b.maxy && m1->yup ) || ( b.maxy==m1->b.miny && !m1->yup ))
@@ -1724,7 +1724,7 @@
 	}
     } else if ( b.maxx==b.minx ) {
 	// We know the x-dimension of the intersection.
-	extended y1,y2;
+	extendeddbl y1,y2;
 	if ( m1->next==m2 || m2->next==m1 )
 return;		/* Not interesting. Only intersection is at an endpoint */
 	if (( b.maxx==m1->b.maxx && m1->xup ) || ( b.maxx==m1->b.minx && !m1->xup ))
@@ -1756,8 +1756,8 @@
 	    int any = false;
 	    if ( doy ) {
                 // We work on y.
-		extended diff, y, x1, x2, x1o ,x2o;
-		extended t1, t2, t1o = -1, t2o = -1;
+		extendeddbl diff, y, x1, x2, x1o ,x2o;
+		extendeddbl t1, t2, t1o = -1, t2o = -1;
 
 		diff = CalculateMinimumDiff(b.miny, (b.maxy-b.miny)/32); // We slice the region into 32nds.
 		y = b.miny;
@@ -1824,15 +1824,15 @@
 			/* A cross over has occurred. (assume we have a small enough */
 			/*  region that three cross-overs can't have occurred) */
 			/* Use a binary search to track it down */
-			extended ytop, ybot, ytest, oldy;
-			extended oldx1 = x1, oldx2=x2;
+			extendeddbl ytop, ybot, ytest, oldy;
+			extendeddbl oldx1 = x1, oldx2=x2;
 			oldy = ytop = y;
 			ybot = y-diff;
 			if ( ybot<b.miny )
 			    ybot = b.miny;
 			x1o = x1; x2o = x2;
 			while ( ytop!=ybot ) {
-			    extended t1t, t2t;
+			    extendeddbl t1t, t2t;
 			    ytest = (ytop+ybot)/2;
 			    t1t = IterateSplineSolveFixup(&m1->s->splines[1],m1->tstart,m1->tend,ytest);
 			    t2t = IterateSplineSolveFixup(&m2->s->splines[1],m2->tstart,m2->tend,ytest);
@@ -1866,8 +1866,8 @@
 		}
 	    } else {
                 // We work on x.
-		extended diff, x, y1, y2, y1o, y2o;
-		extended t1, t2, t1o = -1, t2o = -1;
+		extendeddbl diff, x, y1, y2, y1o, y2o;
+		extendeddbl t1, t2, t1o = -1, t2o = -1;
 
 		diff = CalculateMinimumDiff(b.minx, (b.maxx-b.minx)/32); // We slice the region into 32nds.
 		x = b.minx;
@@ -1928,14 +1928,14 @@
 			/* A cross over has occurred. (assume we have a small enough */
 			/*  region that three cross-overs can't have occurred) */
 			/* Use a binary search to track it down */
-			extended xtop, xbot, xtest, oldx;
-			extended oldy1 = y1, oldy2=y2;
+			extendeddbl xtop, xbot, xtest, oldx;
+			extendeddbl oldy1 = y1, oldy2=y2;
 			oldx = xtop = x;
 			xbot = x-diff;
 			if ( xbot<b.minx ) xbot = b.minx;
 			y1o = y1; y2o = y2;
 			while ( xtop!=xbot ) {
-			    extended t1t, t2t;
+			    extendeddbl t1t, t2t;
 			    xtest = (xtop+xbot)/2;
 			    t1t = IterateSplineSolveFixup(&m1->s->splines[0],m1->tstart,m1->tend,xtest);
 			    t2t = IterateSplineSolveFixup(&m2->s->splines[0],m2->tstart,m2->tend,xtest);
@@ -1976,9 +1976,9 @@
 return;
 }
 
-static extended SplineContainsPoint(Monotonic *m,BasePoint *pt) {
+static extendeddbl SplineContainsPoint(Monotonic *m,BasePoint *pt) {
     int which, nw;
-    extended t;
+    extendeddbl t;
 
     which = ( m->b.maxx-m->b.minx > m->b.maxy-m->b.miny )? 0 : 1;
     nw = !which;
@@ -2002,9 +2002,9 @@
 /* If two splines are coincident, then pretend they intersect at both */
 /*  end-points and nowhere else */
 static int CoincidentIntersect(Monotonic *m1,Monotonic *m2,BasePoint *pts,
-	extended *t1s,extended *t2s) {
+	extendeddbl *t1s,extendeddbl *t2s) {
     int cnt=0;
-    extended t, t2, diff;
+    extendeddbl t, t2, diff;
 
     if ( m1==m2 )
 return( false );		/* Stupid question */
@@ -2058,7 +2058,7 @@
     t1s[2] = t2s[2] = -1;
     if ( !m1->s->knownlinear || !m2->s->knownlinear ) {
 	if ( t1s[1]<t1s[0] ) {
-	    extended temp = t1s[1]; t1s[1] = t1s[0]; t1s[0] = temp;
+	    extendeddbl temp = t1s[1]; t1s[1] = t1s[0]; t1s[0] = temp;
 	    temp = t2s[1]; t2s[1] = t2s[0]; t2s[0] = temp;
 	}
 	diff = (t1s[1]-t1s[0])/16;
@@ -2284,7 +2284,7 @@
 static Intersection *FindIntersections(Monotonic **ms, enum overlap_type ot) {
     Monotonic *m1, *m2;
     BasePoint pts[9];
-    extended t1s[10], t2s[10];
+    extendeddbl t1s[10], t2s[10];
     Intersection *ilist=NULL;
     int i;
     // For each monotonic, check against each other monotonic for an intersection.
@@ -2348,7 +2348,7 @@
 }
 
 static int dcmp(const void *_p1, const void *_p2) {
-    const extended *dpt1 = _p1, *dpt2 = _p2;
+    const extendeddbl *dpt1 = _p1, *dpt2 = _p2;
     if ( *dpt1>*dpt2 )
 return( 1 );
     else if ( *dpt1<*dpt2 )
@@ -2357,14 +2357,14 @@
 return( 0 );
 }
 
-static extended *FindOrderedEndpoints(Monotonic *ms,int which) {
+static extendeddbl *FindOrderedEndpoints(Monotonic *ms,int which) {
     int cnt;
     Monotonic *m;
-    extended *ends;
+    extendeddbl *ends;
     int i,j,k;
 
     for ( m=ms, cnt=0; m!=NULL; m=m->linked, ++cnt );
-    ends = malloc((2*cnt+1)*sizeof(extended));
+    ends = malloc((2*cnt+1)*sizeof(extendeddbl));
     for ( m=ms, cnt=0; m!=NULL; m=m->linked, cnt+=2 ) {
 	if ( m->start!=NULL )
 	    ends[cnt] = (&m->start->inter.x)[which];
@@ -2382,7 +2382,7 @@
 		    m->s->splines[which].c)*m->tend+m->s->splines[which].d;
     }
 
-    qsort(ends,cnt,sizeof(extended),dcmp);
+    qsort(ends,cnt,sizeof(extendeddbl),dcmp);
     for ( i=0; i<cnt; ++i ) {
 	for ( j=i; j<cnt && ends[i]==ends[j]; ++j );
 	if ( j>i+1 ) {
@@ -2415,12 +2415,12 @@
   return 1;
 }
 
-int MonotonicFindAt(Monotonic *ms,int which, extended test, Monotonic **space ) {
+int MonotonicFindAt(Monotonic *ms,int which, extendeddbl test, Monotonic **space ) {
     /* Find all monotonic sections which intersect the line (x,y)[which] == test */
     /*  find the value of the other coord on that line */
     /*  Order them (by the other coord) */
     /*  then run along that line figuring out which monotonics are needed */
-    extended t;
+    extendeddbl t;
     Monotonic *m, *mm;
     int i, j, k, cnt;
     int nw = !which;
@@ -2664,7 +2664,7 @@
 return( false );
 }
 
-static void FigureNeeds(Monotonic *ms,int which, extended test, Monotonic **space,
+static void FigureNeeds(Monotonic *ms,int which, extendeddbl test, Monotonic **space,
 	enum overlap_type ot, bigreal close_level) {
     /* Find all monotonic sections which intersect the line (x,y)[which] == test */
     /*  find the value of the other coord on that line */
@@ -2772,7 +2772,7 @@
 		which ? "y" : "x", (double) test );
 }
 
-struct gaps { extended test, len; int which; };
+struct gaps { extendeddbl test, len; int which; };
 
 static int gcmp(const void *_p1, const void *_p2) {
     const struct gaps *gpt1 = _p1, *gpt2 = _p2;
@@ -2785,12 +2785,12 @@
 }
 
 static Intersection *FindNeeded(Monotonic *ms,enum overlap_type ot,Intersection *ilist) {
-    extended *ends[2];
+    extendeddbl *ends[2];
     Monotonic *m, **space;
-    extended top, bottom, test, last, gap_len;
+    extendeddbl top, bottom, test, last, gap_len;
     int i,j,k,l, cnt,which;
     struct gaps *gaps;
-    extended min_gap;
+    extendeddbl min_gap;
     static const bigreal closeness_level[] = { .1, .01, 0, -1 };
 
     if ( ms==NULL )
@@ -2968,9 +2968,9 @@
     }
 }
 
-static void MonoFigure(Spline *s,extended firstt,extended endt, SplinePoint *first,
+static void MonoFigure(Spline *s,extendeddbl firstt,extendeddbl endt, SplinePoint *first,
 	SplinePoint *end) {
-    extended f;
+    extendeddbl f;
     Spline1D temp;
 
     f = endt - firstt;
@@ -3423,7 +3423,7 @@
     Spline *s = m->s;
     SplinePoint *last = s->from;
     SplinePoint *final = s->to;
-    extended lastt = 0;
+    extendeddbl lastt = 0;
 
     last->next = NULL;
     final->prev = NULL;
@@ -3461,7 +3461,7 @@
 }
 
 static int BpClose(BasePoint *here, BasePoint *there, bigreal error) {
-    extended dx, dy;
+    extendeddbl dx, dy;
 
     if ( (dx = here->x-there->x)<0 ) dx= -dx;
     if ( (dy = here->y-there->y)<0 ) dy= -dy;
@@ -3474,7 +3474,7 @@
 static SplineSet *SSRemoveTiny(SplineSet *base) {
     DBounds b;
     bigreal error;
-    extended test, dx, dy;
+    extendeddbl test, dx, dy;
     SplineSet *prev = NULL, *head = base, *ssnext;
     SplinePoint *sp, *nsp;
 
@@ -3735,7 +3735,7 @@
     bigreal t, tdiff, t1 = -1;
     bigreal xoff, yoff;
     bigreal t1start, t1end;
-    extended ts[2];
+    extendeddbl ts[2];
     int i;
 
     if ( (xoff = s2->to->me.x-s2->from->me.x)<0 ) xoff = -xoff;
--- a/fontforge/splineoverlap.h
+++ b/fontforge/splineoverlap.h
@@ -5,7 +5,7 @@
 #include "splinefont.h"
 
 extern int CheckMonotonicClosed(struct monotonic *ms);
-extern int MonotonicFindAt(Monotonic *ms, int which, extended test, Monotonic **space);
+extern int MonotonicFindAt(Monotonic *ms, int which, extendeddbl test, Monotonic **space);
 /* overlap_type controls whether we look at selected splinesets or all splinesets */
 extern Monotonic *SSsToMContours(SplineSet *spl, enum overlap_type ot);
 extern SplineSet *SplineSetRemoveOverlap(SplineChar *sc, SplineSet *base, enum overlap_type ot);
--- a/fontforge/splinestroke.c
+++ b/fontforge/splinestroke.c
@@ -888,7 +888,7 @@
  */
 SplinePoint *AppendCubicSplinePortion(Spline *s, bigreal t_fm, bigreal t_to,
                                       SplinePoint *tailp) {
-    extended u_fm = 1-t_fm, u_to = 1-t_to;
+    extendeddbl u_fm = 1-t_fm, u_to = 1-t_to;
     SplinePoint *sp;
     BasePoint v, qf, qcf, qct, qt;
 
@@ -1297,7 +1297,7 @@
 				 int *curved, int reverse, int nci_hint) {
     int next_curved, icnt, i;
     bigreal next_t;
-    extended poi[2];
+    extendeddbl poi[2];
     BasePoint next_ut;
 
     assert( cur_ut!=NULL && curved!=NULL );
--- a/fontforge/splineutil.c
+++ b/fontforge/splineutil.c
@@ -497,7 +497,7 @@
 LinearApprox *SplineApproximate(Spline *spline, real scale) {
     LinearApprox *test;
     LineList *cur, *last=NULL;
-    extended poi[2], lastt;
+    extendeddbl poi[2], lastt;
     int i,n;
 
     for ( test = spline->approx; test!=NULL && test->scale!=scale; test = test->next );
@@ -3334,9 +3334,9 @@
 /* I use -999999 as an error flag, since we're really only interested in */
 /*  solns near 0 and 1 that should be ok. -1 is perhaps a little too close */
 /* Sigh. When solutions are near 0, the rounding errors are appalling. */
-int _CubicSolve(const Spline1D *sp,bigreal sought, extended ts[3]) {
-    extended d, xN, yN, delta2, temp, delta, h, t2, t3, theta;
-    extended sa=sp->a, sb=sp->b, sc=sp->c, sd=sp->d-sought;
+int _CubicSolve(const Spline1D *sp,bigreal sought, extendeddbl ts[3]) {
+    extendeddbl d, xN, yN, delta2, temp, delta, h, t2, t3, theta;
+    extendeddbl sa=sp->a, sb=sp->b, sc=sp->c, sd=sp->d-sought;
     int i=0;
 
     ts[0] = ts[1] = ts[2] = -999999;
@@ -3344,24 +3344,24 @@
 	/* one of the roots is 0, the other two are the soln of a quadratic */
 	ts[0] = 0;
 	if ( sc==0 ) {
-	    ts[1] = -sb/(extended) sa;	/* two zero roots */
+	    ts[1] = -sb/(extendeddbl) sa;	/* two zero roots */
 	} else {
-	    temp = sb*(extended) sb-4*(extended) sa*sc;
+	    temp = sb*(extendeddbl) sb-4*(extendeddbl) sa*sc;
 	    if ( RealNear(temp,0))
-		ts[1] = -sb/(2*(extended) sa);
+		ts[1] = -sb/(2*(extendeddbl) sa);
 	    else if ( temp>=0 ) {
 		temp = sqrt(temp);
-		ts[1] = (-sb+temp)/(2*(extended) sa);
-		ts[2] = (-sb-temp)/(2*(extended) sa);
+		ts[1] = (-sb+temp)/(2*(extendeddbl) sa);
+		ts[2] = (-sb-temp)/(2*(extendeddbl) sa);
 	    }
 	}
     } else if ( sa!=0 ) {
     /* http://www.m-a.org.uk/eb/mg/mg077ch.pdf */
     /* this nifty solution to the cubic neatly avoids complex arithmatic */
-	xN = -sb/(3*(extended) sa);
+	xN = -sb/(3*(extendeddbl) sa);
 	yN = ((sa*xN + sb)*xN+sc)*xN + sd;
 
-	delta2 = (sb*(extended) sb-3*(extended) sa*sc)/(9*(extended) sa*sa);
+	delta2 = (sb*(extendeddbl) sb-3*(extendeddbl) sa*sc)/(9*(extendeddbl) sa*sa);
 	/*if ( RealWithin(delta2,0,.00000001) ) delta2 = 0;*/
 
 	/* the descriminant is yN^2-h^2, but delta might be <0 so avoid using h */
@@ -3397,24 +3397,24 @@
 	    if ( xN>=-0.0001 && xN<=1.0001 ) ts[0] = xN;
 	}
     } else if ( sb!=0 ) {
-	extended d = sc*(extended) sc-4*(extended) sb*sd;
+	extendeddbl d = sc*(extendeddbl) sc-4*(extendeddbl) sb*sd;
 	if ( d<0 && RealNear(d,0)) d=0;
 	if ( d<0 )
 return(false);		/* All roots imaginary */
 	d = sqrt(d);
-	ts[0] = (-sc-d)/(2*(extended) sb);
-	ts[1] = (-sc+d)/(2*(extended) sb);
+	ts[0] = (-sc-d)/(2*(extendeddbl) sb);
+	ts[1] = (-sc+d)/(2*(extendeddbl) sb);
     } else if ( sc!=0 ) {
-	ts[0] = -sd/(extended) sc;
+	ts[0] = -sd/(extendeddbl) sc;
     } else {
 	/* If it's a point then either everything is a solution, or nothing */
     }
 return( ts[0]!=-999999 );
 }
 
-int CubicSolve(const Spline1D *sp,bigreal sought, extended ts[3]) {
-    extended t;
-    extended ts2[3];
+int CubicSolve(const Spline1D *sp,bigreal sought, extendeddbl ts[3]) {
+    extendeddbl t;
+    extendeddbl ts2[3];
     int i,j;
     /* This routine gives us all solutions between [0,1] with -1 as an error flag */
     /* http://mathforum.org/dr.math/faq/faq.cubic.equations.html */
@@ -3447,8 +3447,8 @@
 return( true );
 }
 
-static int _QuarticSolve(Quartic *q,extended ts[4]) {
-    extended extrema[5];
+static int _QuarticSolve(Quartic *q,extendeddbl ts[4]) {
+    extendeddbl extrema[5];
     Spline1D sp;
     int ecnt = 0, i, zcnt;
 
@@ -3478,15 +3478,15 @@
 	if ( extrema[1]!=-999999 ) {
 	    ecnt = 2;
 	    if ( extrema[1]<extrema[0] ) {
-		extended temp = extrema[1]; extrema[1] = extrema[0]; extrema[0]=temp;
+		extendeddbl temp = extrema[1]; extrema[1] = extrema[0]; extrema[0]=temp;
 	    }
 	    if ( extrema[2]!=-999999 ) {
 		ecnt = 3;
 		if ( extrema[2]<extrema[0] ) {
-		    extended temp = extrema[2]; extrema[2] = extrema[0]; extrema[0]=temp;
+		    extendeddbl temp = extrema[2]; extrema[2] = extrema[0]; extrema[0]=temp;
 		}
 		if ( extrema[2]<extrema[1] ) {
-		    extended temp = extrema[2]; extrema[2] = extrema[1]; extrema[1]=temp;
+		    extendeddbl temp = extrema[2]; extrema[2] = extrema[1]; extrema[1]=temp;
 		}
 	    }
 	}
@@ -3499,14 +3499,14 @@
     ecnt += 2;
     /* divide into monotonic sections & use binary search to find zeroes */
     for ( i=zcnt=0; i<ecnt-1; ++i ) {
-	extended top, bottom, val;
-	extended topt, bottomt, t;
+	extendeddbl top, bottom, val;
+	extendeddbl topt, bottomt, t;
 	topt = extrema[i+1];
 	bottomt = extrema[i];
 	top = (((q->a*topt+q->b)*topt+q->c)*topt+q->d)*topt+q->e;
 	bottom = (((q->a*bottomt+q->b)*bottomt+q->c)*bottomt+q->d)*bottomt+q->e;
 	if ( top<bottom ) {
-	    extended temp = top; top = bottom; bottom = temp;
+	    extendeddbl temp = top; top = bottom; bottom = temp;
 	    temp = topt; topt = bottomt; bottomt = temp;
 	}
 	if ( bottom>.001 )	/* this monotonic is all above 0 */
@@ -3546,13 +3546,13 @@
 return( zcnt );
 }
 
-extended SplineSolve(const Spline1D *sp, real tmin, real tmax, extended sought) {
+extendeddbl SplineSolve(const Spline1D *sp, real tmin, real tmax, extendeddbl sought) {
     /* We want to find t so that spline(t) = sought */
     /*  the curve must be monotonic */
     /* returns t which is near sought or -1 */
-    extended ts[3];
+    extendeddbl ts[3];
     int i;
-    extended t;
+    extendeddbl t;
 
     CubicSolve(sp,sought,ts);
     if ( tmax<tmin ) { t = tmax; tmax = tmin; tmin = t; }
@@ -3569,12 +3569,12 @@
 /* But that's not going to work near 0, so, since the t values we care about */
 /*  are [0,1], let's use 1.0/D_RE_Factor */
 
-extended SplineSolveFixup(const Spline1D *sp, real tmin, real tmax, extended sought) {
-    extended ts[3];
+extendeddbl SplineSolveFixup(const Spline1D *sp, real tmin, real tmax, extendeddbl sought) {
+    extendeddbl ts[3];
     int i;
     bigreal factor;
-    extended t;
-    extended val, valp, valm;
+    extendeddbl t;
+    extendeddbl val, valp, valm;
 
     CubicSolve(sp,sought,ts);
     if ( tmax<tmin ) { t = tmax; tmax = tmin; tmin = t; }
@@ -3584,8 +3584,8 @@
     if ( i==3 ) {
 	/* nothing in range, but ... */
 	/* did a rounding error take a solution just outside the bounds? */
-	extended bestd = .0001; int besti = -1;
-	extended off;
+	extendeddbl bestd = .0001; int besti = -1;
+	extendeddbl off;
 	for ( i=0; i<3 && ts[i]!=-1; ++i ) {
 	    if ( ts[i]<tmin )
 		off = tmin-ts[i];
@@ -3606,8 +3606,8 @@
 	val=-val;
     if ( val!=0 ) {
 	for ( factor=1024.0*1024.0*1024.0*1024.0*1024.0; factor>.5; factor/=2.0 ) {
-	    extended tp = t + (factor*t)/D_RE_Factor;
-	    extended tm = t - (factor*t)/D_RE_Factor;
+	    extendeddbl tp = t + (factor*t)/D_RE_Factor;
+	    extendeddbl tm = t - (factor*t)/D_RE_Factor;
 	    if ( (valp = (((sp->a*tp+sp->b)*tp+sp->c)*tp+sp->d) - sought)<0 )
 		valp = -valp;
 	    if ( (valm = (((sp->a*tm+sp->b)*tm+sp->c)*tm+sp->d) - sought)<0 )
@@ -3635,9 +3635,9 @@
 return( -1 );
 }
 
-extended IterateSplineSolve(const Spline1D *sp, extended tmin, extended tmax,
-	extended sought) {
-    extended t, low, high, test;
+extendeddbl IterateSplineSolve(const Spline1D *sp, extendeddbl tmin, extendeddbl tmax,
+	extendeddbl sought) {
+    extendeddbl t, low, high, test;
     Spline1D temp;
     /* Now the closed form CubicSolver can have rounding errors so if we know */
     /*  the spline to be monotonic, an iterative approach is more accurate */
@@ -3650,7 +3650,7 @@
     temp.d -= sought;
 
     if ( temp.a==0 && temp.b==0 && temp.c!=0 ) {
-	t = -temp.d/(extended) temp.c;
+	t = -temp.d/(extendeddbl) temp.c;
 	if ( t<tmin || t>tmax )
 return( -1 );
 return( t );
@@ -3685,12 +3685,12 @@
 return( -1 );
 }
 
-extended IterateSplineSolveFixup(const Spline1D *sp, extended tmin, extended tmax,
-	extended sought) {
+extendeddbl IterateSplineSolveFixup(const Spline1D *sp, extendeddbl tmin, extendeddbl tmax,
+	extendeddbl sought) {
     // Search between tmin and tmax for a t-value at which the spline outputs sought.
-    extended t;
+    extendeddbl t;
     bigreal factor;
-    extended val, valp, valm;
+    extendeddbl val, valp, valm;
 
     if ( tmin>tmax ) {
 	t=tmin; tmin=tmax; tmax=t;
@@ -3705,8 +3705,8 @@
 	val=-val;
     if ( val!=0 ) {
 	for ( factor=1024.0*1024.0*1024.0*1024.0*1024.0; factor>.5; factor/=2.0 ) {
-	    extended tp = t + (factor*t)/D_RE_Factor;
-	    extended tm = t - (factor*t)/D_RE_Factor;
+	    extendeddbl tp = t + (factor*t)/D_RE_Factor;
+	    extendeddbl tm = t - (factor*t)/D_RE_Factor;
 	    if ( tp>tmax ) tp=tmax;
 	    if ( tm<tmin ) tm=tmin;
 	    if ( (valp = (((sp->a*tp+sp->b)*tp+sp->c)*tp+sp->d) - sought)<0 )
@@ -3782,9 +3782,9 @@
 return( t );
 }
 
-static void _SplineFindExtrema(const Spline1D *sp, extended *_t1, extended *_t2 ) {
-    extended t1= -1, t2= -1;
-    extended b2_fourac;
+static void _SplineFindExtrema(const Spline1D *sp, extendeddbl *_t1, extendeddbl *_t2 ) {
+    extendeddbl t1= -1, t2= -1;
+    extendeddbl b2_fourac;
 
     /* Find the extreme points on the curve */
     /*  Set to -1 if there are none or if they are outside the range [0,1] */
@@ -3794,30 +3794,30 @@
     /*  (Does not check to see if d/dt==0 points are inflection points (rather than extrema) */
     if ( sp->a!=0 ) {
 	/* cubic, possibly 2 extrema (possibly none) */
-	b2_fourac = 4*(extended)sp->b*sp->b - 12*(extended)sp->a*sp->c;
+	b2_fourac = 4*(extendeddbl)sp->b*sp->b - 12*(extendeddbl)sp->a*sp->c;
 	if ( b2_fourac>=0 ) {
 	    b2_fourac = sqrt(b2_fourac);
 	    t1 = (-2*sp->b - b2_fourac) / (6*sp->a);
 	    t2 = (-2*sp->b + b2_fourac) / (6*sp->a);
 	    t1 = CheckExtremaForSingleBitErrors(sp,t1,t2);
 	    t2 = CheckExtremaForSingleBitErrors(sp,t2,t1);
-	    if ( t1>t2 ) { extended temp = t1; t1 = t2; t2 = temp; }
+	    if ( t1>t2 ) { extendeddbl temp = t1; t1 = t2; t2 = temp; }
 	    else if ( t1==t2 ) t2 = -1;
 	    if ( RealNear(t1,0)) t1=0; else if ( RealNear(t1,1)) t1=1;
 	    if ( RealNear(t2,0)) t2=0; else if ( RealNear(t2,1)) t2=1;
 	}
     } else if ( sp->b!=0 ) {
 	/* Quadratic, at most one extremum */
-	t1 = -sp->c/(2.0*(extended) sp->b);
+	t1 = -sp->c/(2.0*(extendeddbl) sp->b);
     } else /*if ( sp->c!=0 )*/ {
 	/* linear, no extrema */
     }
     *_t1 = t1; *_t2 = t2;
 }
 
-void SplineFindExtrema(const Spline1D *sp, extended *_t1, extended *_t2 ) {
-    extended t1= -1, t2= -1;
-    extended b2_fourac;
+void SplineFindExtrema(const Spline1D *sp, extendeddbl *_t1, extendeddbl *_t2 ) {
+    extendeddbl t1= -1, t2= -1;
+    extendeddbl b2_fourac;
 
     /* Find the extreme points on the curve */
     /*  Set to -1 if there are none or if they are outside the range [0,1] */
@@ -3827,14 +3827,14 @@
     /*  (Does not check to see if d/dt==0 points are inflection points (rather than extrema) */
     if ( sp->a!=0 ) {
 	/* cubic, possibly 2 extrema (possibly none) */
-	b2_fourac = 4*(extended) sp->b*sp->b - 12*(extended) sp->a*sp->c;
+	b2_fourac = 4*(extendeddbl) sp->b*sp->b - 12*(extendeddbl) sp->a*sp->c;
 	if ( b2_fourac>=0 ) {
 	    b2_fourac = sqrt(b2_fourac);
 	    t1 = (-2*sp->b - b2_fourac) / (6*sp->a);
 	    t2 = (-2*sp->b + b2_fourac) / (6*sp->a);
 	    t1 = CheckExtremaForSingleBitErrors(sp,t1,t2);
 	    t2 = CheckExtremaForSingleBitErrors(sp,t2,t1);
-	    if ( t1>t2 ) { extended temp = t1; t1 = t2; t2 = temp; }
+	    if ( t1>t2 ) { extendeddbl temp = t1; t1 = t2; t2 = temp; }
 	    else if ( t1==t2 ) t2 = -1;
 	    if ( RealNear(t1,0)) t1=0; else if ( RealNear(t1,1)) t1=1;
 	    if ( RealNear(t2,0)) t2=0; else if ( RealNear(t2,1)) t2=1;
@@ -3843,7 +3843,7 @@
 	}
     } else if ( sp->b!=0 ) {
 	/* Quadratic, at most one extremum */
-	t1 = -sp->c/(2.0*(extended) sp->b);
+	t1 = -sp->c/(2.0*(extendeddbl) sp->b);
 	if ( t1<=0 || t1>=1 ) t1 = -1;
     } else /*if ( sp->c!=0 )*/ {
 	/* linear, no extrema */
@@ -3885,7 +3885,7 @@
 	    !RealNear( 6*sp->a*t + 2*sp->b, 0));
 }
 
-int Spline2DFindExtrema(const Spline *sp, extended extrema[4] ) {
+int Spline2DFindExtrema(const Spline *sp, extendeddbl extrema[4] ) {
     int i,j;
     BasePoint last, cur, mid;
 
@@ -3903,7 +3903,7 @@
 
     for ( i=0; i<3; ++i ) for ( j=i+1; j<4; ++j ) {
 	if ( (extrema[i]==-1 && extrema[j]!=-1) || (extrema[i]>extrema[j] && extrema[j]!=-1) ) {
-	    extended temp = extrema[i];
+	    extendeddbl temp = extrema[i];
 	    extrema[i] = extrema[j];
 	    extrema[j] = temp;
 	}
@@ -3951,9 +3951,9 @@
 return( i );
 }
 
-int Spline2DFindPointsOfInflection(const Spline *sp, extended poi[2] ) {
+int Spline2DFindPointsOfInflection(const Spline *sp, extendeddbl poi[2] ) {
     int cnt=0;
-    extended a, b, c, b2_fourac, t;
+    extendeddbl a, b, c, b2_fourac, t;
     /* A POI happens when d2 y/dx2 is zero. This is not the same as d2y/dt2 / d2x/dt2 */
     /* d2 y/dx^2 = d/dt ( dy/dt / dx/dt ) / dx/dt */
     /*		 = ( (dx/dt) * d2 y/dt2 - ((dy/dt) * d2 x/dt2) )/ (dx/dt)^3 */
@@ -3963,9 +3963,9 @@
     /* -(9*ax*ay*t^3 + (3ay*bx+6by*ax)*t^2 + (2by*bx+3cy*ax)*t + cy*bx)==0 */
     /* 3*(ax*by-ay*bx)*t^2 + 3*(cx*ay-cy*ax)*t+ (cx*by-cy*bx) == 0	   */
 
-    a = 3*((extended) sp->splines[1].a*sp->splines[0].b-(extended) sp->splines[0].a*sp->splines[1].b);
-    b = 3*((extended) sp->splines[0].c*sp->splines[1].a - (extended) sp->splines[1].c*sp->splines[0].a);
-    c = (extended) sp->splines[0].c*sp->splines[1].b-(extended) sp->splines[1].c*sp->splines[0].b;
+    a = 3*((extendeddbl) sp->splines[1].a*sp->splines[0].b-(extendeddbl) sp->splines[0].a*sp->splines[1].b);
+    b = 3*((extendeddbl) sp->splines[0].c*sp->splines[1].a - (extendeddbl) sp->splines[1].c*sp->splines[0].a);
+    c = (extendeddbl) sp->splines[0].c*sp->splines[1].b-(extendeddbl) sp->splines[1].c*sp->splines[0].b;
     if ( !RealNear(a,0) ) {
 	b2_fourac = b*b - 4*a*c;
 	poi[0] = poi[1] = -1;
@@ -3999,9 +3999,9 @@
 /*  from an endpoint or another extremum, then many things are */
 /*  just going to skip over it, and other things will be confused by this */
 /*  so just remove it. It should be so close the difference won't matter */
-void SplineRemoveExtremaTooClose(Spline1D *sp, extended *_t1, extended *_t2 ) {
-    extended last, test;
-    extended t1= *_t1, t2 = *_t2;
+void SplineRemoveExtremaTooClose(Spline1D *sp, extendeddbl *_t1, extendeddbl *_t2 ) {
+    extendeddbl last, test;
+    extendeddbl t1= *_t1, t2 = *_t2;
 
     if ( t1>t2 && t2!=-1 ) {
 	t1 = t2;
@@ -4135,8 +4135,8 @@
 return( true );
 }
 
-static int AddPoint(extended x,extended y,extended t,extended s,BasePoint *pts,
-	extended t1s[3],extended t2s[3], int soln) {
+static int AddPoint(extendeddbl x,extendeddbl y,extendeddbl t,extendeddbl s,BasePoint *pts,
+	extendeddbl t1s[3],extendeddbl t2s[3], int soln) {
     int i;
 
     for ( i=0; i<soln; ++i )
@@ -4151,14 +4151,14 @@
 return( soln+1 );
 }
 
-static void IterateSolve(const Spline1D *sp,extended ts[3]) {
+static void IterateSolve(const Spline1D *sp,extendeddbl ts[3]) {
     /* The closed form solution has too many rounding errors for my taste... */
     int i,j;
 
     ts[0] = ts[1] = ts[2] = -1;
 
     if ( sp->a!=0 ) {
-	extended e[4];
+	extendeddbl e[4];
 	e[0] = 0; e[1] = e[2] = e[3] = 1.0;
 	SplineFindExtrema(sp,&e[1],&e[2]);
 	if ( e[1]==-1 ) e[1] = 1;
@@ -4170,7 +4170,7 @@
 	break;
 	}
     } else if ( sp->b!=0 ) {
-	extended b2_4ac = sp->c*(extended) sp->c - 4*sp->b*(extended) sp->d;
+	extendeddbl b2_4ac = sp->c*(extendeddbl) sp->c - 4*sp->b*(extendeddbl) sp->d;
 	if ( b2_4ac>=0 ) {
 	    b2_4ac = sqrt(b2_4ac);
 	    ts[0] = (-sp->c-b2_4ac)/(2*sp->b);
@@ -4178,7 +4178,7 @@
 	    if ( ts[0]>ts[1] ) { bigreal t = ts[0]; ts[0] = ts[1]; ts[1] = t; }
 	}
     } else if ( sp->c!=0 ) {
-	ts[0] = -sp->d/(extended) sp->c;
+	ts[0] = -sp->d/(extendeddbl) sp->c;
     } else {
 	/* No solutions, or all solutions */
 	;
@@ -4196,16 +4196,16 @@
 	}
     if ( j!=0 ) {
 	if ( ts[0]!=0 ) {
-	    extended d0 = sp->d;
-	    extended dt = ((sp->a*ts[0]+sp->b)*ts[0]+sp->c)*ts[0]+sp->d;
+	    extendeddbl d0 = sp->d;
+	    extendeddbl dt = ((sp->a*ts[0]+sp->b)*ts[0]+sp->c)*ts[0]+sp->d;
 	    if ( d0<0 ) d0=-d0;
 	    if ( dt<0 ) dt=-dt;
 	    if ( d0<dt )
 		ts[0] = 0;
 	}
 	if ( ts[j-1]!=1.0 ) {
-	    extended d1 = sp->a+(extended) sp->b+sp->c+sp->d;
-	    extended dt = ((sp->a*ts[j-1]+sp->b)*ts[j-1]+sp->c)*ts[j-1]+sp->d;
+	    extendeddbl d1 = sp->a+(extendeddbl) sp->b+sp->c+sp->d;
+	    extendeddbl dt = ((sp->a*ts[j-1]+sp->b)*ts[j-1]+sp->c)*ts[j-1]+sp->d;
 	    if ( d1<0 ) d1=-d1;
 	    if ( dt<0 ) dt=-dt;
 	    if ( d1<dt )
@@ -4216,10 +4216,10 @@
 	ts[j] = -1;
 }
 
-static extended ISolveWithin(const Spline *spline,int major,
-	extended val,extended tlow, extended thigh) {
+static extendeddbl ISolveWithin(const Spline *spline,int major,
+	extendeddbl val,extendeddbl tlow, extendeddbl thigh) {
     Spline1D temp;
-    extended ts[3];
+    extendeddbl ts[3];
     const Spline1D *sp = &spline->splines[major];
     int i;
 
@@ -4258,8 +4258,8 @@
 return( -1 );
 }
 
-static int ICAddInter(int cnt,BasePoint *foundpos,extended *foundt1,extended *foundt2,
-	const Spline *s1,const Spline *s2,extended t1,extended t2, int maxcnt) {
+static int ICAddInter(int cnt,BasePoint *foundpos,extendeddbl *foundt1,extendeddbl *foundt2,
+	const Spline *s1,const Spline *s2,extendeddbl t1,extendeddbl t2, int maxcnt) {
 
     if ( cnt>=maxcnt )
 return( cnt );
@@ -4273,13 +4273,13 @@
 return( cnt+1 );
 }
 
-static int ICBinarySearch(int cnt,BasePoint *foundpos,extended *foundt1,extended *foundt2,
+static int ICBinarySearch(int cnt,BasePoint *foundpos,extendeddbl *foundt1,extendeddbl *foundt2,
 	int other,
-	const Spline *s1,const Spline *s2,extended t1low,extended t1high,extended t2low,extended t2high,
+	const Spline *s1,const Spline *s2,extendeddbl t1low,extendeddbl t1high,extendeddbl t2low,extendeddbl t2high,
 	int maxcnt) {
     int major;
-    extended t1, t2;
-    extended o1o, o2o, o1n, o2n, m;
+    extendeddbl t1, t2;
+    extendeddbl o1o, o2o, o1n, o2n, m;
 
     major = !other;
     o1o = ((s1->splines[other].a*t1low+s1->splines[other].b)*t1low+
@@ -4311,14 +4311,14 @@
     }
 }
 
-static int CubicsIntersect(const Spline *s1,extended lowt1,extended hight1,BasePoint *min1,BasePoint *max1,
-			    const Spline *s2,extended lowt2,extended hight2,BasePoint *min2,BasePoint *max2,
-			    BasePoint *foundpos,extended *foundt1,extended *foundt2,
+static int CubicsIntersect(const Spline *s1,extendeddbl lowt1,extendeddbl hight1,BasePoint *min1,BasePoint *max1,
+			    const Spline *s2,extendeddbl lowt2,extendeddbl hight2,BasePoint *min2,BasePoint *max2,
+			    BasePoint *foundpos,extendeddbl *foundt1,extendeddbl *foundt2,
 			    int maxcnt) {
     int major, other;
     BasePoint max, min;
-    extended t1max, t1min, t2max, t2min, t1, t2, t1diff, oldt2;
-    extended o1o, o2o, o1n, o2n, m;
+    extendeddbl t1max, t1min, t2max, t2min, t1, t2, t1diff, oldt2;
+    extendeddbl o1o, o2o, o1n, o2n, m;
     int cnt=0;
 
     if ( (min.x = min1->x)<min2->x ) min.x = min2->x;
@@ -4387,7 +4387,7 @@
 return( cnt );
 }
 
-static int Closer(const Spline *s1,const Spline *s2,extended t1,extended t2,extended t1p,extended t2p) {
+static int Closer(const Spline *s1,const Spline *s2,extendeddbl t1,extendeddbl t2,extendeddbl t1p,extendeddbl t2p) {
     bigreal x1 = ((s1->splines[0].a*t1+s1->splines[0].b)*t1+s1->splines[0].c)*t1+s1->splines[0].d;
     bigreal y1 = ((s1->splines[1].a*t1+s1->splines[1].b)*t1+s1->splines[1].c)*t1+s1->splines[1].d;
     bigreal x2 = ((s2->splines[0].a*t2+s2->splines[0].b)*t2+s2->splines[0].c)*t2+s2->splines[0].d;
@@ -4409,14 +4409,14 @@
 /*  -1 => We couldn't figure it out in a closed form, have to do a numerical */
 /*  approximation */
 int SplinesIntersect(const Spline *s1, const Spline *s2, BasePoint pts[9],
-	extended t1s[10], extended t2s[10]) {	/* One extra for a trailing -1 */
+	extendeddbl t1s[10], extendeddbl t2s[10]) {	/* One extra for a trailing -1 */
     BasePoint min1, max1, min2, max2;
     int soln = 0;
-    extended x,y,t, ac0, ac1;
+    extendeddbl x,y,t, ac0, ac1;
     int i,j,found;
     Spline1D spline;
-    extended tempts[4];	/* 3 solns for cubics, 4 for quartics */
-    extended extrema1[6], extrema2[6];
+    extendeddbl tempts[4];	/* 3 solns for cubics, 4 for quartics */
+    extendeddbl extrema1[6], extrema2[6];
     int ecnt1, ecnt2;
 
     t1s[0] = t1s[1] = t1s[2] = t1s[3] = -1;
@@ -4446,7 +4446,7 @@
 	/* Do Nothing */;
     else if ( s2->knownlinear || (!s1->isquadratic && s2->isquadratic)) {
 	const Spline *stemp = s1;
-	extended *ts = t1s;
+	extendeddbl *ts = t1s;
 	t1s = t2s; t2s = ts;
 	s1 = s2; s2 = stemp;
     }
@@ -4570,8 +4570,8 @@
 		s1->splines[0].c)*extrema1[i+1]+s1->splines[0].d;
 	max1.y = ((s1->splines[1].a*extrema1[i+1]+s1->splines[1].b)*extrema1[i+1]+
 		s1->splines[1].c)*extrema1[i+1]+s1->splines[1].d;
-	if ( max1.x<min1.x ) { extended temp = max1.x; max1.x = min1.x; min1.x = temp; }
-	if ( max1.y<min1.y ) { extended temp = max1.y; max1.y = min1.y; min1.y = temp; }
+	if ( max1.x<min1.x ) { extendeddbl temp = max1.x; max1.x = min1.x; min1.x = temp; }
+	if ( max1.y<min1.y ) { extendeddbl temp = max1.y; max1.y = min1.y; min1.y = temp; }
 	for ( j=(s1==s2)?i+1:0; j<ecnt2; ++j ) {
 	    min2.x = ((s2->splines[0].a*extrema2[j]+s2->splines[0].b)*extrema2[j]+
 		    s2->splines[0].c)*extrema2[j]+s2->splines[0].d;
@@ -4581,8 +4581,8 @@
 		    s2->splines[0].c)*extrema2[j+1]+s2->splines[0].d;
 	    max2.y = ((s2->splines[1].a*extrema2[j+1]+s2->splines[1].b)*extrema2[j+1]+
 		    s2->splines[1].c)*extrema2[j+1]+s2->splines[1].d;
-	    if ( max2.x<min2.x ) { extended temp = max2.x; max2.x = min2.x; min2.x = temp; }
-	    if ( max2.y<min2.y ) { extended temp = max2.y; max2.y = min2.y; min2.y = temp; }
+	    if ( max2.x<min2.x ) { extendeddbl temp = max2.x; max2.x = min2.x; min2.x = temp; }
+	    if ( max2.y<min2.y ) { extendeddbl temp = max2.y; max2.y = min2.y; min2.y = temp; }
 	    if ( min1.x>max2.x || min2.x>max1.x || min1.y>max2.y || min2.y>max1.y )
 		/* No possible intersection */;
 	    else if ( s1!=s2 )
@@ -4662,7 +4662,7 @@
 
 int SplineSetIntersect(SplineSet *spl, Spline **_spline, Spline **_spline2) {
     BasePoint pts[9];
-    extended t1s[10], t2s[10];
+    extendeddbl t1s[10], t2s[10];
     int found = false,i;
     SplineSet *test, *test2;
     Spline *spline, *spline2, *first, *first2;
@@ -4705,8 +4705,8 @@
 return( found );
 }
 
-int LineTangentToSplineThroughPt(Spline *s, BasePoint *pt, extended ts[4],
-	extended tmin, extended tmax) {
+int LineTangentToSplineThroughPt(Spline *s, BasePoint *pt, extendeddbl ts[4],
+	extendeddbl tmin, extendeddbl tmax) {
     /* attempt to find a line though the point pt which is tangent to the spline */
     /*  we return t of the tangent point on the spline (if any)		  */
     /* So the slope of the line through pt&tangent point must match slope */
@@ -4812,7 +4812,7 @@
     Spline1D *yspline = &spline->splines[1], *xspline = &spline->splines[0];
 
     if ( xspline->a!=0 ) {
-	extended t1, t2, tbase;
+	extendeddbl t1, t2, tbase;
 	SplineFindExtrema(xspline,&t1,&t2);
 	tbase = 0;
 	if ( t1!=-1 ) {
@@ -4921,7 +4921,7 @@
 	    if ( fs->xl<x && fs->xh>x && t>=0 && t<=1 )
 return( true );
 	} else {
-	    extended t1, t2, tbase;
+	    extendeddbl t1, t2, tbase;
 	    SplineFindExtrema(yspline,&t1,&t2);
 	    tbase = 0;
 	    if ( t1!=-1 ) {
@@ -5030,7 +5030,7 @@
 }
 
 static int Crossings(Spline *s,BasePoint *pt) {
-    extended ext[4];
+    extendeddbl ext[4];
     int i, cnt=0;
     bigreal yi, yi1, t, x;
 
@@ -7260,7 +7260,7 @@
     /* Remove extrema which are very close to one of the spline end-points */
     /*  and which are in the oposite direction (along the normal of the */
     /*  close end-point's cp) from the other end-point */
-    extended ts[2], t1, t2;
+    extendeddbl ts[2], t1, t2;
     bigreal df, dt;
     bigreal dp, d_o;
     int i;
@@ -7423,7 +7423,7 @@
 return( changed );
 }
 
-SplinePoint *SplineBisect(Spline *spline, extended t) {
+SplinePoint *SplineBisect(Spline *spline, extendeddbl t) {
     Spline1 xstart, xend;
     Spline1 ystart, yend;
     Spline *spline1, *spline2;
@@ -7437,8 +7437,8 @@
 	IError("Bisection to create a zero length spline");
 #endif
     xstart.s0 = xsp->d; ystart.s0 = ysp->d;
-    xend.s1 = (extended) xsp->a+xsp->b+xsp->c+xsp->d;
-    yend.s1 = (extended) ysp->a+ysp->b+ysp->c+ysp->d;
+    xend.s1 = (extendeddbl) xsp->a+xsp->b+xsp->c+xsp->d;
+    yend.s1 = (extendeddbl) ysp->a+ysp->b+ysp->c+ysp->d;
     xstart.s1 = xend.s0 = ((xsp->a*t+xsp->b)*t+xsp->c)*t + xsp->d;
     ystart.s1 = yend.s0 = ((ysp->a*t+ysp->b)*t+ysp->c)*t + ysp->d;
     FigureSpline1(&xstart,0,t,xsp);
@@ -7506,7 +7506,7 @@
 return( mid );
 }
 
-Spline *SplineSplit(Spline *spline, extended ts[3]) {
+Spline *SplineSplit(Spline *spline, extendeddbl ts[3]) {
     /* Split the current spline in up to 3 places */
     Spline1 splines[2][4];
     int i,cnt;
@@ -7636,7 +7636,7 @@
     int any=0;
     Spline *s, *first;
     Spline1D *ws, *zs;
-    extended ts[3];
+    extendeddbl ts[3];
     bigreal w, z;
     int i;
     int other = !major;
--- a/fontforge/splineutil.h
+++ b/fontforge/splineutil.h
@@ -30,27 +30,27 @@
 extern EncMap *EncMapNew(int enccount, int backmax, Encoding *enc);
 
 /* Uses an iterative approximation */
-extern extended IterateSplineSolve(const Spline1D *sp, extended tmin, extended tmax, extended sought_y);
+extern extendeddbl IterateSplineSolve(const Spline1D *sp, extendeddbl tmin, extendeddbl tmax, extendeddbl sought_y);
 /* Uses an iterative approximation and then tries to fix things up */
-extern extended IterateSplineSolveFixup(const Spline1D *sp, extended tmin, extended tmax, extended sought_y);
+extern extendeddbl IterateSplineSolveFixup(const Spline1D *sp, extendeddbl tmin, extendeddbl tmax, extendeddbl sought_y);
 
 extern FPST *FPSTCopy(FPST *fpst);
 extern HintMask *HintMaskFromTransformedRef(RefChar *ref, BasePoint *trans, SplineChar *basesc,HintMask *hm);
 extern ImageList *ImageListCopy(ImageList *cimg);
 extern ImageList *ImageListTransform(ImageList *img, real transform[6], int everything);
 extern int CountKerningClasses(SplineFont *sf);
-extern int _CubicSolve(const Spline1D *sp, bigreal sought, extended ts[3]);
+extern int _CubicSolve(const Spline1D *sp, bigreal sought, extendeddbl ts[3]);
 extern int GroupNameType(const char *input);
 extern int IntersectLines(BasePoint *inter, BasePoint *line1_1, BasePoint *line1_2, BasePoint *line2_1, BasePoint *line2_2);
 extern int IntersectLinesClip(BasePoint *inter, BasePoint *line1_1, BasePoint *line1_2, BasePoint *line2_1, BasePoint *line2_2);
 extern int IntersectLinesSlopes(BasePoint *inter, BasePoint *line1, BasePoint *slope1, BasePoint *line2, BasePoint *slope2);
-extern int LineTangentToSplineThroughPt(Spline *s, BasePoint *pt, extended ts[4], extended tmin, extended tmax);
+extern int LineTangentToSplineThroughPt(Spline *s, BasePoint *pt, extendeddbl ts[4], extendeddbl tmin, extendeddbl tmax);
 extern int NearSpline(FindSel *fs, Spline *spline);
 extern int SCRoundToCluster(SplineChar *sc, int layer, int sel, bigreal within, bigreal max);
 extern int SFKerningGroupExistsSpecific(const struct splinefont *sf, const char *groupname, int isv, int isr);
 extern int SpExistsInSS(SplinePoint *sp, SplineSet *ss);
-extern int Spline2DFindExtrema(const Spline *sp, extended extrema[4]);
-extern int Spline2DFindPointsOfInflection(const Spline *sp, extended poi[2]);
+extern int Spline2DFindExtrema(const Spline *sp, extendeddbl extrema[4]);
+extern int Spline2DFindPointsOfInflection(const Spline *sp, extendeddbl poi[2]);
 extern int SplineAtInflection(Spline1D *sp, bigreal t);
 extern int SplineAtMinMax(Spline1D *sp, bigreal t);
 extern int SplineExistsInSS(Spline *s, SplineSet *ss);
@@ -63,7 +63,7 @@
 /* Two lines intersect in at most 1 point */
 /* Two quadratics intersect in at most 4 points */
 /* Two cubics intersect in at most 9 points */ /* Plus an extra space for a trailing -1 */
-extern int SplinesIntersect(const Spline *s1, const Spline *s2, BasePoint pts[9], extended t1s[10], extended t2s[10]);
+extern int SplinesIntersect(const Spline *s1, const Spline *s2, BasePoint pts[9], extendeddbl t1s[10], extendeddbl t2s[10]);
 
 extern int SplineT2SpiroIndex(Spline *spline, bigreal t, SplineSet *spl);
 extern int SSBoundsWithin(SplineSet *ss, bigreal z1, bigreal z2, bigreal *wmin, bigreal *wmax, int major);
@@ -90,12 +90,12 @@
 extern SplinePointList *SplinePointListSpiroTransform(SplinePointList *base, real transform[6], int allpoints);
 extern SplinePointList *SplinePointListTransformExtended(SplinePointList *base, real transform[6], enum transformPointType tpt, enum transformPointMask tpmask);
 
-extern SplinePoint *SplineBisect(Spline *spline, extended t);
+extern SplinePoint *SplineBisect(Spline *spline, extendeddbl t);
 extern SplinePoint *SplinePointCreate(real x, real y);
 extern SplineSet *LayerAllSplines(Layer *layer);
 extern SplineSet *LayerUnAllSplines(Layer *layer);
 extern Spline *SplineMake3(SplinePoint *from, SplinePoint *to);
-extern Spline *SplineSplit(Spline *spline, extended ts[3]);
+extern Spline *SplineSplit(Spline *spline, extendeddbl ts[3]);
 extern struct baselangextent *BaseLangCopy(struct baselangextent *extent);
 extern struct ff_glyphclasses *SFGetGroup(const struct splinefont *sf, int index, const char *name);
 extern struct glyphvariants *GlyphVariantsCopy(struct glyphvariants *gv);
@@ -184,7 +184,7 @@
 extern void SplineCharListsFree(struct splinecharlist *dlist);
 extern void SplineCharQuickBounds(SplineChar *sc, DBounds *b);
 extern void SplineCharQuickConservativeBounds(SplineChar *sc, DBounds *b);
-extern void SplineFindExtrema(const Spline1D *sp, extended *_t1, extended *_t2);
+extern void SplineFindExtrema(const Spline1D *sp, extendeddbl *_t1, extendeddbl *_t2);
 extern void SplineFontClearSpecial(SplineFont *sf);
 extern void SplineFontFindBounds(SplineFont *sf, DBounds *bounds);
 extern void SplineFontFree(SplineFont *sf);
@@ -201,7 +201,7 @@
 extern void SplinePointListsMDFree(SplineChar *sc, SplinePointList *spl);
 extern void SplinePointMDFree(SplineChar *sc, SplinePoint *sp);
 extern void SplinePointsFree(SplinePointList *spl);
-extern void SplineRemoveExtremaTooClose(Spline1D *sp, extended *_t1, extended *_t2);
+extern void SplineRemoveExtremaTooClose(Spline1D *sp, extendeddbl *_t1, extendeddbl *_t2);
 extern void SplineSetBeziersClear(SplinePointList *spl);
 extern void SplineSetFindBounds(const SplinePointList *spl, DBounds *bounds);
 extern void SplineSetQuickBounds(SplineSet *ss, DBounds *b);
--- a/fontforge/splineutil2.c
+++ b/fontforge/splineutil2.c
@@ -214,10 +214,10 @@
 }
 
 static int MinMaxWithin(Spline *spline) {
-    extended dx, dy;
+    extendeddbl dx, dy;
     int which;
-    extended t1, t2;
-    extended w;
+    extendeddbl t1, t2;
+    extendeddbl w;
     /* We know that this "spline" is basically one dimensional. As long as its*/
     /*  extrema are between the start and end points on that line then we can */
     /*  treat it as a line. If the extrema are way outside the line segment */
@@ -1613,7 +1613,7 @@
 /*  check that that is less than err					      */
 static int SplineCloseToLinear(Spline *s, bigreal err) {
     bigreal angle;
-    extended co,si, t1, t2, y;
+    extendeddbl co,si, t1, t2, y;
     SplinePoint from, to;
     Spline sp;
     BasePoint bp;
@@ -2667,7 +2667,7 @@
 	} else if ( s->splines[0].a!=0 ) {
 	    bigreal d = 4*s->splines[0].b*s->splines[0].b-4*3*s->splines[0].a*s->splines[0].c;
 	    if ( d>0 ) {
-		extended t1, t2;
+		extendeddbl t1, t2;
 		d = sqrt(d);
 		t1 = (-2*s->splines[0].b+d)/(2*3*s->splines[0].a);
 		t2 = (-2*s->splines[0].b-d)/(2*3*s->splines[0].a);
@@ -2714,7 +2714,7 @@
 	} else if ( s->splines[1].a!=0 ) {
 	    bigreal d = 4*s->splines[1].b*s->splines[1].b-4*3*s->splines[1].a*s->splines[1].c;
 	    if ( d>0 ) {
-		extended t1,t2;
+		extendeddbl t1,t2;
 		d = sqrt(d);
 		t1 = (-2*s->splines[1].b+d)/(2*3*s->splines[1].a);
 		t2 = (-2*s->splines[1].b-d)/(2*3*s->splines[1].a);
--- a/fontforge/stemdb.c
+++ b/fontforge/stemdb.c
@@ -596,7 +596,7 @@
     Spline *s;
     int i,j,k,cnt;
     BasePoint pts[9];
-    extended lts[10], sts[10];
+    extendeddbl lts[10], sts[10];
 
     for ( i=j=0; (s=sspace[j])!=NULL; ++j ) {
 	if ( BBoxIntersectsLine(s,line) ) {
@@ -2606,7 +2606,7 @@
     SplinePoint end1, end2;
     double width,t,sign, len, dot;
     BasePoint pts[9];
-    extended lts[10], sts[10];
+    extendeddbl lts[10], sts[10];
     BasePoint diff;
     struct stemdata *stem ;
     
--- a/fontforge/utanvec.c
+++ b/fontforge/utanvec.c
@@ -145,7 +145,7 @@
 bigreal SplineSolveForUTanVec(Spline *spl, BasePoint ut, bigreal min_t,
                               bool picky) {
     bigreal tmp, yto;
-    extended te1, te2;
+    extendeddbl te1, te2;
     Spline1D ys1d;
 
     // Nothing to "solve" for; lines should be handled by different means
--- a/fontforgeexe/charview.c
+++ b/fontforgeexe/charview.c
@@ -1317,7 +1317,7 @@
 static void CVMarkInterestingLocations(CharView *cv, GWindow pixmap,
 	SplinePointList *spl) {
     Spline *s, *first;
-    extended interesting[6];
+    extendeddbl interesting[6];
     CharViewTab* tab = CVGetActiveTab(cv);
     int i, ecnt, cnt;
     GRect r;
@@ -10267,7 +10267,7 @@
 	int err = false;
 	struct insertonsplineat *iosa = GDrawGetUserData(GGadgetGetWindow(g));
 	double val;
-	extended ts[3];
+	extendeddbl ts[3];
 	int which;
 	SplinePoint *sp;
 
--- a/fontforgeexe/cvknife.c
+++ b/fontforgeexe/cvknife.c
@@ -187,7 +187,7 @@
     Spline dummy;
     SplinePoint dummyfrom, dummyto, *mid, *mid2;
     BasePoint inters[9];
-    extended t1s[10], t2s[10];
+    extendeddbl t1s[10], t2s[10];
     int foundsomething = true, ever = false;
     int i;
     int spiro_index = 0;
--- a/fontforgeexe/problems.c
+++ b/fontforgeexe/problems.c
@@ -1693,7 +1693,7 @@
 	Spline *s, *first;
 	double len2, bound2 = p->sc->parent->extrema_bound;
 	double x,y;
-	extended extrema[4];
+	extendeddbl extrema[4];
 
 	if ( bound2<=0 )
 	    bound2 = (p->sc->parent->ascent + p->sc->parent->descent)/32.0;
--- a/fontforgeexe/cvruler.c
+++ b/fontforgeexe/cvruler.c
@@ -374,7 +374,7 @@
     Spline dummy;
     SplinePoint dummyfrom, dummyto;
     BasePoint inters[9];	/* These bounds are hard coded in the SplinesIntersect function */
-    extended t1s[10], t2s[10];
+    extendeddbl t1s[10], t2s[10];
     int i;
     int total_intersections = 0;
 
